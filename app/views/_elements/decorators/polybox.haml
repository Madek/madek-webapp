:ruby
  # TODO: i18n
  default_fallback = "(No content.)"

  # This is a presenter-spezific decorator for MediaResources!

  pres = media_resources # shortcut
  unless pres and pres.is_a?(Presenters::Shared::MediaResources::MediaResources)
    throw 'ui! need a MediaResourcesIndex Presenter!'
  end

  title ||= title
  # fallback can be a string or just 'true', in which case we use default string
  fallback ||= fallback
  fallback = default_fallback if fallback and not fallback.is_a?(String)

  # there are several "view modes", default is grid
  view_modes = [:grid, :tiles]
  classes.push :grid unless view_modes.any? {|mode| classes.include? mode }


  # for each type of resource, build the list of polythumbs
  resource_types = {
    media_entries: pres.media_entries.map do |get|
      deco('polythumb',
        title: get.title,
        thumb: component('thumbnail',
          mods: ['media-entry'], # TODO : type of entry ('video')
          text: get.title,
          picture: get.image_url,
          href: get.url,
          # yes this is *inside* the thumbâ€¦ workaround hacky CSS :/
          meta: {
            title: get.title,
            subtitle: get.authors
          },
          badge_top_left: component('privacy-icon', status: get.privacy_status)
        )
      )
    end,
    collections: pres.collections.map do |get|
      deco('polythumb',
        title: get.title,
        thumb: component('thumbnail',
          mods: ['media-set'],
          text: get.title,
          href: get.url,
          picture: get.image_url,
          meta: {
            title: get.title#,
            # subtitle: 'TODO'
          },
          badge_top_left: component('privacy-icon', status: get.privacy_status)
        )
      )
    end,
    filter_sets: pres.filter_sets.map do |get|
      deco('polythumb',
        title: get.title,
        thumb: component('thumbnail',
          mods: ['filter-set'],
          text: get.title,
          href: get.url,
          picture: get.image_url,
          meta: {
            title: get.title#,
            # subtitle: 'TODO'
          },
          badge_top_left: component('privacy-icon', status: get.privacy_status),
          badge_top_right: component('icon.filter')
        )
      )
    end
  }

  # also build an appropriate filter_bar
  filter_bar = combo('button-group', {
    mods: ['js-only', 'small'],
    list: [
      (pres.media_entries.empty? ? nil : {
        text: 'Entries',
        hook: 'entries'
      }),
      (pres.collections.empty? ? nil : {
        text: 'Collections',
        hook: 'collections'
      }),
      (pres.filter_sets.empty? ? nil : {
        text: 'FilterSets',
        hook: 'filter_sets'
      })
    ]
  })

  # check if we got any non-empty list
  all_lists_are_empty = resource_types
                .map { |_k, v| v.empty?}
                .reduce { |a, b| a && b}


-# a list for each kind of resource.
  - skips empty lists
  - rendered as consective units
  - re-uses pagination elements
  - TODO: ujs: use filterbar ui + tab logic

.POLYBOX
  = combo('resources-header', title: title, filter_bar: filter_bar)

  - return fallback if all_lists_are_empty

  %ul.ui-resources{class: classes}

    -# a unit for each type of resource
    - resource_types.each do |type, resources_list|
      - unless resources_list.empty?
        %li.ui-resources-page

          -# a small heading TODO: txt()
          %span.ui-resources-page-counter.ui-pager.small
            = type

          -# the actual box of items
          %ul.ui-resources-page-items
            - resources_list.each do |item|
              = item
