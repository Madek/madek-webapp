:ruby
  # NOTE: only 1 is allowed per view/page!
  # If that need ever to be changed, pagination needs to be addressed.

  # TODO: i18n
  default_fallback = "(No content.)"
  elm_anchor = 'resources-page'

  # This is a presenter-spezific decorator for any MediaResource:
  pres = media_resources

  title ||= nil
  link ||= nil
  fallback ||= nil
  # fallback can be a string or just 'true', in which case we use default string
  fallback = default_fallback if fallback and not fallback.is_a?(String)
  # mod 'unpaginated' omits all pagination elements (shown by default)
  show_pagination_nav = !classes.map(&:to_s).include?('unpaginated')

  # sanity check:
    unless pres.empty? and fallback.present?
      unless \
        pres.media_entries.is_a?(Presenters::MediaEntries::MediaEntries) \
        or pres.collections.is_a?(Presenters::Collections::Collections) \
        or pres.filter_sets.is_a?(Presenters::FilterSets::FilterSets)
        throw 'ui: polybox: need a `MediaResources` Presenter!'
      end
    end

  # there are several "view modes", default is grid
  view_modes = [:grid, :tiles]
  classes.push :grid unless view_modes.any? {|mode| classes.include? mode }

  # check if we got any non-empty list
  all_lists_are_empty = pres.empty?

  # for each type of resource, build the list of polythumbs
  resource_types = {
    media_entries: (pres.media_entries.try(:resources) || []).map do |get|
      deco('polythumb') { deco('thumbnail', get: get) }
    end,
    collections: (pres.collections.try(:resources) || []).map do |get|
      deco('polythumb') { deco('thumbnail', get: get) }
    end,
    filter_sets: (pres.filter_sets.try(:resources) || []).map do |get|
      deco('polythumb') { deco('thumbnail', get: get) }
    end
  }

  # TODO: also build an appropriate filter_bar
  # filter_bar = combo('button-group', {
  #   mods: ['js-only', 'small'],
  #   list: [
  #     (!pres.media_entries.any? ? nil : {
  #       text: 'Entries',
  #       hook: 'entries'
  #     }),
  #     (!pres.collections.any? ? nil : {
  #       text: 'Collections',
  #       hook: 'collections'
  #     }),
  #     (!pres.filter_sets.any? ? nil : {
  #       text: 'FilterSets',
  #       hook: 'filter_sets'
  #     })
  #   ]
  # })

  # build pagination navigation. TODO: combo
  # get nav info
  # pagination = pres.pagination_info
  # TMP: fake multiple collection handling, just take biggest one:
  pagination = if
    pag = [:media_entries, :collections, :filter_sets]
      .map {|type| pres.send(type).try(:pagination_info) }
      .compact
      .sort_by {|p| p.total_pages}
      .last

    # build nav links links (conserves any other parameters)
    nav = ['previous_page', 'next_page'].map do |id|
      if pag[id]
        [id, url_for(params.merge(page: pag[id], anchor: elm_anchor))]
      end
    end.compact.to_h

    return unless pag && nav
    pag.nav = nav
    pag
  end

-# a list of media_resources.
  - TODO: ujs: use filterbar ui + tab logic

.POLYBOX.pbl{id: elm_anchor}
  - if title
    = title

  - return fallback if all_lists_are_empty

  %ul.ui-resources{class: classes}

    - if pagination && show_pagination_nav && pagination.total_pages > 1
      .no-js
        %span.ui-resources-page-counter.ui-pager
          = "Page #{pagination.current_page} of #{pagination.total_pages}"

    -# a unit for each type of resource
    - resource_types.each do |type, resources_list|
      - unless resources_list.empty?
        %li.ui-resources-page.mhn.mtn.pbm

          -# a small heading TODO: txt(), count
          %span.ui-resources-page-counter.ui-pager.small
            - count = pres[type].pagination_info.total_count
            - name = count > 1 ? type : type.to_s.singularize
            = "#{count} #{name.to_s.camelize}"

          -# the actual box of items
          %ul.ui-resources-page-items
            - resources_list.each do |item|
              = item

    - if show_pagination_nav && pagination.nav.any?
      .row
        - pagination.nav.each do |id, link|
          = component('button', text: id.to_s.humanize,
                               href: link)
