:ruby
  # NOTE: only 1 is allowed per view/page!
  # If that need ever to be changed, pagination needs to be addressed.

  # TODO: i18n
  default_fallback = "(No content.)"
  elm_anchor = 'resources-page'

  # This is a presenter-spezific decorator for any MediaResource:
  pres = media_resources
  # sanity check:
    unless \
      pres.media_entries.is_a?(Presenters::MediaEntries::MediaEntries) \
      or pres.collections.is_a?(Presenters::Collections::Collections) \
      or pres.filter_sets.is_a?(Presenters::FilterSets::FilterSets)
      throw 'ui: polybox: need a `MediaResources` Presenter!'
    end

  title ||= nil
  link ||= nil
  # fallback can be a string or just 'true', in which case we use default string
  fallback ||= fallback
  fallback = default_fallback if fallback and not fallback.is_a?(String)
  # mod 'unpaginated' omits all pagination elements (shown by default)
  show_pagination_nav = !classes.map(&:to_s).include?('unpaginated')

  # there are several "view modes", default is grid
  view_modes = [:grid, :tiles]
  classes.push :grid unless view_modes.any? {|mode| classes.include? mode }

  # check if we got any non-empty list
  all_lists_are_empty = pres.empty?

  # for each type of resource, build the list of polythumbs
  resource_types = {
    media_entries: (pres.media_entries.try(:resources) || []).map do |get|
      deco('polythumb',
        title: get.title,
        thumb: component('thumbnail',
          mods: ['media-entry'], # TODO : type of entry ('video')
          text: get.title,
          picture: get.image_url,
          href: get.url,
          # yes this is *inside* the thumbâ€¦ workaround hacky CSS :/
          meta: {
            title: get.title,
            subtitle: get.authors
          },
          badge_top_left: component('privacy-icon', status: get.privacy_status)
        )
      )
    end,
    collections: (pres.collections.try(:resources) || []).map do |get|
      deco('polythumb',
        title: get.title,
        thumb: component('thumbnail',
          mods: ['media-set'],
          text: get.title,
          href: get.url,
          picture: get.image_url,
          meta: {
            title: get.title#,
            # subtitle: 'TODO'
          },
          badge_top_left: component('privacy-icon', status: get.privacy_status)
        )
      )
    end,
    filter_sets: (pres.filter_sets.try(:resources) || []).map do |get|
      deco('polythumb',
        title: get.title,
        thumb: component('thumbnail',
          mods: ['filter-set'],
          text: get.title,
          href: get.url,
          picture: get.image_url,
          meta: {
            title: get.title#,
            # subtitle: 'TODO'
          },
          badge_top_left: component('privacy-icon', status: get.privacy_status),
          badge_top_right: component('icon.filter')
        )
      )
    end
  }

  # TODO: also build an appropriate filter_bar
  # filter_bar = combo('button-group', {
  #   mods: ['js-only', 'small'],
  #   list: [
  #     (!pres.media_entries.any? ? nil : {
  #       text: 'Entries',
  #       hook: 'entries'
  #     }),
  #     (!pres.collections.any? ? nil : {
  #       text: 'Collections',
  #       hook: 'collections'
  #     }),
  #     (!pres.filter_sets.any? ? nil : {
  #       text: 'FilterSets',
  #       hook: 'filter_sets'
  #     })
  #   ]
  # })

  # build pagination navigation. TODO: combo
  # get nav info
  # pagination = pres.pagination_info
  # TMP: fake multiple collection handling, just take biggest one:
  pagination = [:media_entries, :collections, :filter_sets]
                .map {|type| pres.send(type).try(:pagination_info) }
                .compact
                .sort_by {|p| p.total_pages}
                .last

  # build nav links links (conserves any other parameters)
  pagination.nav = ['previous_page', 'next_page'].map do |id|
    if pagination[id]
      [id, url_for(params.merge(page: pagination[id], anchor: elm_anchor))]
    end
  end.compact.to_h

-# a list of media_resources.
  - TODO: ujs: use filterbar ui + tab logic

.POLYBOX.pbl{id: elm_anchor}
  - if title
    = title

  - return fallback if all_lists_are_empty

  %ul.ui-resources{class: classes}

    - if show_pagination_nav && pagination.total_pages > 1
      .no-js
        %span.ui-resources-page-counter.ui-pager
          = "Page #{pagination.current_page} of #{pagination.total_pages}"

    -# a unit for each type of resource
    - resource_types.each do |type, resources_list|
      - unless resources_list.empty?
        %li.ui-resources-page.mhn.mtn.pbm

          -# a small heading TODO: txt(), count
          %span.ui-resources-page-counter.ui-pager.small
            - count = pres[type].pagination_info.total_count
            - name = count > 1 ? type : type.to_s.singularize
            = "#{count} #{name.to_s.camelize}"

          -# the actual box of items
          %ul.ui-resources-page-items
            - resources_list.each do |item|
              = item

    - if show_pagination_nav && pagination.nav.any?
      .row
        - pagination.nav.each do |id, link|
          = component('button', text: id.to_s.humanize,
                               href: link)
